import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ParallelCSVProcessing {
    public static void main(String[] args) {
        String inputFilePath = "input.csv"; // Replace with the path to your input CSV file
        String outputFilePath = "output.csv"; // Replace with the desired output file path

        int numThreads = Runtime.getRuntime().availableProcessors(); // Use available CPU cores
        ExecutorService executorService = Executors.newFixedThreadPool(numThreads);

        try (CSVReader reader = new CSVReader(new FileReader(inputFilePath));
             CSVWriter writer = new CSVWriter(new FileWriter(outputFilePath))) {

            // Read the header from the input CSV and add a new column for "Status"
            String[] header = reader.readNext();
            String[] newHeader = addColumn(header, "Status");
            writer.writeNext(newHeader);

            String[] nextLine;
            while ((nextLine = reader.readNext()) != null) {
                final String[] row = nextLine;
                executorService.submit(() -> {
                    // Process each row here, you can modify and add data as needed
                    String[] processedRow = processRow(row);
                    writer.writeNext(processedRow);
                });
            }

            executorService.shutdown();
            executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static String[] addColumn(String[] row, String columnName) {
        String[] newRow = new String[row.length + 1];
        System.arraycopy(row, 0, newRow, 0, row.length);
        newRow[row
